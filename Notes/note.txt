import { Slider } from '@mui/material'     <Slider/>
import {Typography} from '@mui/material'   <Typography> text here </Typography>

import { Carousel } from 'react-responsive-carousel';    
import 'react-responsive-carousel/lib/styles/carousel.min.css';

import {toast} from'react-hot-toast'
import { useDispatch, useSelector } from 'react-redux'

import ReactStars from 'react-rating-stars-component'     <ReactStars {...options}/>

we can access Link tag in css using "a" (anchor tag notation)
we can target Typography tag using "p" in css


In React Router v6, the Routes component replaces the Switch component, and the Route component is replaced by the Route element inside the Routes component. Additionally, the element prop is replaced by the element JSX attribute. Here's your code adapted for React Router v6:

import { DataGrid } from '@mui/x-data-grid';
import { Step, Stepper,StepLabel, Typography } from '@mui/material'

import LibraryAddCheckIcon from '@mui/icons-material/LibraryAddCheck';
import LocalShippingIcon from '@mui/icons-material/LocalShipping';
import AccountBalanceIcon from '@mui/icons-material/AccountBalance';

npm i chart.js react-chartjs-2


______________________________________________________________________________________________________________________
It is a complete functional Ecommerce Website (like flipkart) Which has some featues like:-
1. Complete Authentication (Login,Registration,Logout)
2. We have 2 roles User or Admin. some routes are specific for Admin Only
3. A user can write a review of the product.
4. User can order & Buy a Product from the Cart using payment gateway of RazorPay.
5. Admin can create the product to sell, he can see the orders.
Tech Stack ;- MongoDB, Reactjs, Nodejs, Express, React-Redux, material-UI
Libraries used :- react-hot-toast, react-icons, react-router-dom, react-js-pagination, react-redux, redux-thunk, axios, country-state-city
Nodejs libraries :- bcrypt, cloudinary, cookie-parser, cors, dotenv, jsonwebtoken, nodemailer, razorpay, validator
_________________________________________________________________________
🚀 E-commerce Platform Development 🌐

🔧 Tech Stack: MongoDB, ReactJS, Node.js, Express, React-Redux, Material-UI

📚 Libraries: Redux-Thunk, Axios, RazorPay, Cloudinary, and more

✨ Highlights:

Authentication: Seamlessly managed user registration, login, and logout processes.
Roles: Implemented two roles - User and Admin, with specific admin-only routes.
User Reviews: Enabled users to share insights through product reviews.
Ordering: Streamlined the purchase process with RazorPay integration.
Admin Control: Empowered admins to create products and monitor orders.
🌍 Project Link: GitHub Repository

Excited to discuss the development journey and explore potential collaborations! Let's connect. 🚀🔗 #Ecommerce #ReactJS #NodeJS #WebDevelopment #TechInnovation


 const handleAddTier = () => {
    // Add a new tier with default values
    //console.log("...tieredpricingCat", [...tieredpricingCat]);
    setTieredpricingCat([
      ...tieredpricingCat,
      { min: 0, max: 0, discount: 0, isPercent: true, price: 0, finalprice: 0 },
    ]);
    validation.setFieldValue("tieredPricing", tieredpricingCat);
  };
------------------------------------------------------------------------------------
After running docker-compose up and waiting for services to start:
curl localhost:4000/healthcheck
Healthy Response (200 OK):
{
  "uptime": 125.67,
  "message": "OK",
  "timestamp": 1620000000000,
  "checks": {
    "kafka": "healthy",
    "database": "healthy",
    "redis": "healthy"
  }
}
  ______________________________________________________________________________________________________________

https://nodejs-todoapp-yor3.onrender.com/task/my

mongodb+srv://aryamantandon18:aryaman123@cluster0.ixbw6jy.mongodb.net/?retryWrites=True

mongodb+srv://tandonaryaman1:aryutanu@cluster0.h67ntmp.mongodb.net/Ecommerce?retryWrites=True     ------

mongodb+srv://tandonaryaman1:aryutanu@cluster0.h67ntmp.mongodb.net/?retryWrites=True
mongodb://127.0.0.1:27017
----------------------------------------------------------------------------------
Explanation of Clustering
Clustering allows Node.js applications to scale more effectively across multi-core systems by creating multiple instances of the application, each running on a separate CPU core. Node.js is single-threaded by default, so without clustering, only one CPU core is used regardless of how many are available. Here’s how clustering works:

Primary vs. Worker Processes:

The primary (or "master") process manages the worker processes and doesn’t directly handle requests.
Worker processes are forked by the primary process to handle actual server requests, allowing each to use a separate core.
Load Balancing:

In cluster mode, the primary process automatically distributes incoming connections among the workers, effectively balancing the load.
Fault Tolerance:

If a worker crashes, the primary process can detect this and restart the worker, increasing the application’s resilience.
Efficient Resource Utilization:

By using all CPU cores, the application can handle more requests concurrently, reducing response time and increasing throughput.

When you call app.listen(port, callback) in Express, it internally uses http.createServer() to create an HTTP server instance and starts listening on the specified port.
By not requiring http.createServer(), Express allows you to skip boilerplate code and directly start adding routes and middleware. This makes your server setup code simpler and easier to maintain.

---------------------------------------REDIS----------------------
docker run -d --name redis-stack -p 6379:6379 -p 8001:8001 redis/redis-stack:latest
docker ps
docker exec -it e3eb36a79f37 bash
redis-cli 
set name aryaman //OK
get name //"aryaman"

-------------------Edit admin Review-----------------
Query:

{ 'reviews._id': new mongoose.Types.ObjectId(reviewId) }:

This query finds the product where the reviews array contains a review with the specified _id.

Update:

$set: { 'reviews.$.rating': rating, 'reviews.$.comment': comment }:

The $ operator refers to the specific review in the reviews array that matched the query.

reviews.$.rating updates the rating field of the matched review.

reviews.$.comment updates the comment field of the matched review.

-----------------------------------dockerfile - backend-----------------------------------
docker build -t ecmm_backend .     // creating a docker image named ecmm_backend and this " . " represents the path of the docker file , which is in the current directory here if we are in backend folder

docker run -d -p 4000:4000 --env-file ./data/config.env ecmm_backend
docker run -d -p 4000:4000 --net ecmm_network --env-file ./data/config.env --name ecmm_back ecmm_backend

docker compose up -d  // or we can use docker compose -f path_to_docker-compose.yaml_file up -d 
docker compose down
------------------------------------------------------------

in multer : 
 Breakdown of cb(null, true)
cb: This is the callback function that Multer provides.
The first argument is an error (if any). If there's no error, pass null.
The second argument is a boolean:
true: Accept the file
false: Reject the file

const fileFilter = (req, file, cb) => {
  if (file.mimetype === 'image/jpeg' || file.mimetype === 'image/png') {
    cb(null, true); // accept only JPEG or PNG files
  } else {
    cb(null, false); // reject other file types
  }
};








start.sh
cd backend && npm run dev & 
cd ../client && npm start

---------------------------------------------------------------------
version: "3.8"
name: ecmm
services:
  # do not need to use the official MongoDB Docker image if we are using MongoDB atlas string
  # mongodb:
  #   image: mongo:7
  #   volumes:
  #     - mongodb_data:/data/db
  #   networks:
  #     - dock_mern

  ecmm_backend_service:
    image: ecmm_backend
    container_name: ecmm_back
    env_file:
      - ./backend/data/config.env
    build: 
      dockerfile: Dockerfile 
      context: "./backend"
    volumes:
      - ./backend:/app
      - logs:/app/logs
    command: npm run dev
    depends_on:
      - mongodb  
    networks:
      - dock_mern

  client:
    build: 
      dockerfile: Dockerfile
      context: ./client 
    ports: 
      - "3000:3000"  
    volumes: 
      - ./client/src:/app/src
    depends_on:
      - api
    networks:
      - dock_mern

volumes:
  mongodb_data:
  logs:

networks:
  dock_mern:



export const deleteReviews = asyncHandler(async(req,res,next)=>{

   const product = await Product.findById(req.query.productId);
   if(!product){
      return next(new ErrorHandler("Product not found",404));
   }
   const reviews = product.reviews.filter(
      (rev) => rev._id.toString() !== req.query.id.toString()
    );

let avg = 0;

product.reviews.forEach((rev) => {
   avg = avg + rev.rating;
})

const newRating = avg/product.reviews.length;

const numOfReviews = product.reviews.length;

await Product.findByIdAndUpdate(req.query.productId,{
   reviews,
   rating : newRating,
   numOfReviews ,
},{ new:true,
   runValidators:true,
   useFindAndModify: false, })

   res.status(200).json({
      success:true,
     })
})

export const getReviewsByUserId = asyncHandler(async(req,res)=>{
  const {userId} = req.params;
  try {
    const reviews = await Product.aggregate([
      {
        $match:{'reviews.user' :  new mongoose.Types.ObjectId(userId)}
      },{
        $unwind: '$reviews'
      },{
        $match:{'reviews.user':  new mongoose.Types.ObjectId(userId)}
      },{
        $project:{
          productId:'$_id',
          reviews:'$reviews'
        }
      }
    ]);

    if(reviews.length === 0){
      return res.status(404).json({
        message:"No reviews for this user"
      })
    }

    return res.status(200).json(reviews)  

  } catch (error) {
    console.error("Line 270 in the productController",error);
    return res.status(500).json({message:"Internal Server Error"})
  }
});

export const getAllReviews = asyncHandler(async(req,res,next)=>{
   const product = await Product.findById(req.query.productId);
   if(!product){
      return next(new ErrorHandler("Product not found",404));
   }
   res.status(200).json({
      success:true,
      reviews: product.reviews,
     })
})